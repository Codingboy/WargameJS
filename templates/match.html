<!doctype html>
<html lang="en">
	<head>
		<meta charset="utf-8">
		<meta http-equiv="X-UA-Compatible" content="IE=edge">
		<meta name="viewport" content="width=device-width, initial-scale=1">
		<link href="static/css/bootstrap.min.css" rel="stylesheet">
		<link rel="stylesheet" href="static/ol.css" type="text/css">
		<style>
			.map {
				height: 100%;
				width: 100%;
			}
		</style>
		<title>BFT</title>
	</head>
	<body onclick="onClick(event);">
		<div class="container">
			<form class="form-horizontal">
				<div class="form-group" id="unitBlock">
					<input type="button" onclick="showGroups()" value="Groups"/>
					<input type="button" onclick="showInfantry()" value="Infantry"/>
					<input type="button" onclick="abortBuy()" value="Abort"/>
				</div>
				<div class="form-group" id="buttonsBlock">
				</div>
				<div class="form-group" id="selectedBlock">
				</div>
			<form>
		</div>
		<div id="map" class="map"></div>
		<script src="https://ajax.googleapis.com/ajax/libs/jquery/1.12.4/jquery.min.js"></script>
		<script src="static/js/bootstrap.min.js"></script>
		<script src="static/ol.js" type="text/javascript"></script>
		<script src="static/dms.js" type="text/javascript"></script>
		<script src="static/latlon-spherical.js" type="text/javascript"></script>
		<script src="static/milsymbol-master/dist/milsymbol.js"></script>
		<script src="static/core.js"></script>
		<script src="static/unit.js"></script>
		<script src="static/group.js"></script>
		<script src="static/weapon.js"></script>
    	<script type="text/javascript" src="//cdnjs.cloudflare.com/ajax/libs/socket.io/1.3.5/socket.io.min.js"></script>
		<script>
			let matchID = parseInt(gup("match"));
			let allPlayers = {};
			let allyGroups = {};
			let hostileGroups = {};
			let allObjects = {};
			let messages = [];
			let player = new Player();
			var socket = io.connect(location.protocol + '//' + document.domain + ':' + location.port);
			socket.open();
			let requestUpdate = false;
			socket.on("connect", function()
			{
				console.log("connect");
				let team = parseInt(gup("team"));
				socket.emit("join", {team: team, matchID: matchID});
			});
			socket.on("join", function(json)
			{
				console.log("join");
				console.log(json);
				player.id = json.id;
				player.name = json.name;
				player.team = json.team;
				requestUpdate = json.requestUpdate;
				delete json.requestUpdate;
				socket.emit("joined", json);
			});
			socket.on("joined", function(json)
			{
				console.log("joined");
				console.log(json);
				if (json.id != player.id)
				{
					let p = new Player();
					p.id = json.id;
					p.name = json.name;
					p.team = json.team;
					allPlayers[p.id] = p;
				}
				else
				{
					allPlayers[player.id] = player;
					if (requestUpdate)
					{
						socket.emit("requestUpdate", {playerID: player.id, matchID: matchID});
					}
				}
			});
			socket.on("requestUpdate", function(json)
			{
				console.log("requestUpdate");
				let playerID = json.playerID;
				if (playerID != player.id)
				{
					console.log(json);
					let user = {};
					user.id = player.id;
					user.name = player.name;
					user.team = player.team;
					json.player = user;
					json.groups = [];
					//TODO myGroups
					socket.emit("update", json);
				}
			});
			socket.on("update", function(json)
			{
				console.log("update");
				let playerID = json.playerID;
				if (playerID == player.id)
				{
					console.log(json);
					let user = {};
					let p = new Player();
					p.id = json.player.id;
					p.name = json.player.name;
					p.team = json.player.team;
					allPlayers[p.id] = p;
					for (let group of json.groups)
					{
					
					}
					//TODO myGroups
				}
			});
			socket.on("communicate", function(json)
			{
				console.log("communicate");
				console.log(json);
				let senderID = json.senderID;
				let matchID = json.matchID;
				let messages = json.messages;
				for (message of messages)
				{
					let messageType = message.type;
					let messageData = message.data;
					if (messageType == "create")
					{
						let id = messageData.id;
						let pos = messageData.pos;
						let units = messageData.units;
						let owner = player;
						for (let playerID of Object.keys(allPlayers))
						{
							if (allPlayers[playerID].id == senderID)
							{
								owner = allPlayers[playerID];
								break;
							}
						}
						let group = new Group(owner, pos, id);
						for (unit of units)
						{
							let weapons = [];
							for (weapon of unit.weapons)
							{
								let w = new Weapon(weapon, weapon.id);
								weapons.push(w);
							}
							let u = new Unit(unit, weapons, group, unit.id);
							for (weapon of u.weapons)
							{
								weapon.unit = u;
								allObjects[weapon.id] = weapon;
							}
							allObjects[u.id] = u;
							group.addUnit(u);
						}
						allObjects[group.id] = group;
						group.redraw();
					}
				}
			});
			var visibleEnemyOpacity = 1.0;
			var invisibleEnemyOpacity = 0.1;
			var selectedOpacity = 1.0;
			var unselectedOpacity = 0.66;
			
			let shift = false;
			let ctrl = false;
			
			let db;
			let toBeSpawnedUnits = [];
			let toBeSpawnedGroups = [];
			let selectedGroups = [];
			
			let fps = 10;
			let timeFactor = 10;
			
			let symbolSource = new ol.source.Vector({
				features: []
			});
			let symbolLayer = new ol.layer.Vector({
				source: symbolSource
			});
			let map = new ol.Map({
				target: "map",
				layers: [
					new ol.layer.Tile({
						preload: Infinity,
						source: new ol.source.OSM()
					}),
					symbolLayer
				],
				view: new ol.View({
					center: ol.proj.fromLonLat([8.2, 50.05]),
					zoom: 15
				}),
				interactions: ol.interaction.defaults({
					doubleClickZoom: false,
					shiftDragZoom: false,
					altShiftDragRotate: false,
					keyboard: false,
					pinchRotate: false,
					pinchZoom: false
				}),
				controls: ol.control.defaults().extend([
					new ol.control.ScaleLine()
				])
			});
			map.on("singleclick", function(evt){
				let latlon = ol.proj.transform(evt.coordinate, "EPSG:3857", "EPSG:4326");
				let lat = latlon[0];
				let lon = latlon[1];
				if (toBeSpawnedUnits.length+toBeSpawnedGroups.length > 0)
				{
					createGroupGlobal(toBeSpawnedUnits, toBeSpawnedGroups, [lat, lon]);
				}
				else
				{
					let selected = false;
					feature = map.forEachFeatureAtPixel(evt.pixel, function (feature, layer)
					{
						return feature;
					});
					if (feature)
					{
						group = feature.get("group");
						selected = true;
						if (shift)
						{
							selectedGroups.push(group);
						}
						else
						{
							for (let g of selectedGroups)
							{
								g.opacity = unselectedOpacity;
								g.needsRedraw = true;
							}
							selectedGroups = [group];
						}
						group.opacity = selectedOpacity;
						group.needsRedraw = true;
					}
					if (!selected)
					{
						for (group of selectedGroups)
						{
							if (shift)
							{
								group.waypoints.push(latlon);
							}
							else
							{
								group.waypoints = [latlon];
							}
						}
					}
				}
			});
			function unitsFromName(unitNames, callback, units)
			{
				if (typeof units == "undefined")
				{
					units = [];
				}
				let unitName = unitNames.shift();
				unitFromName(unitName, function(dbUnit)
				{
					units.push(dbUnit);
					if (unitNames.length == 0)
					{
						callback(units);
					}
					else
					{
						unitsFromName(unitNames, callback, units);
					}
				});
			}
			function unitFromName(unitName, callback)
			{
				let req = db.transaction(["units"]).objectStore("units").get(unitName);
				req.onsuccess = function(event)
				{
					let dbUnit = event.target.result;
					if (dbUnit)
					{
						dbUnit.id = -1;
						for (let i=0; i<dbUnit.weapons.length; i++)
						{
							dbUnit.weaponCount = 0;
							weaponFromName(dbUnit.weapons[i], dbUnit, i, callback);
						}
						if (dbUnit.weapons.length == 0)
						{
							dbUnit.weapons = [];
							callback(dbUnit);
						}
					}
				};
			}
			function weaponFromName(weaponName, dbUnit, i, callback)
			{
				let req = db.transaction(["weapons"]).objectStore("weapons").get(weaponName);
				req.onsuccess = function(event)
				{
					let dbWeapon = event.target.result;
					if (dbWeapon)
					{
						dbWeapon.id = -1;
						dbUnit.weapons[i] = dbWeapon;
					}
					dbUnit.weaponCount += 1;
					if (dbUnit.weaponCount == dbUnit.weapons.length)
					{
						delete dbUnit.weaponCount;
						callback(dbUnit);
					}
				};
			}
			function onClick(e)
			{
				shift = e.shiftKey;
				ctrl = e.ctrlKey;
			}
			function init()
			{
				window.indexedDB = window.indexedDB || window.mozIndexedDB || window.webkitIndexedDB || window.msIndexedDB;
				window.IDBTransaction = window.IDBTransaction || window.webkitIDBTransaction || window.msIDBTransaction;
				window.IDBKeyRange = window.IDBKeyRange || window.webkitIDBKeyRange || window.msIDBKeyRange;
				initDB(function(event)
				{
					db = event.target.result;
					/*let group = new Group(opfor, [8.2, 50.05]);
					for (let i=0; i<32; i++)
					{
						group.addUnit("Rifleman");
					}*/
				});
			}
			init();
			function reset()
			{
				toBeSpawnedUnits = [];
				toBeSpawnedGroups = [];
				let groupsElement = document.getElementById("buttonsBlock");
				for (let i=0; i<groupsElement.childNodes.length; i++)
				{
					if (groupsElement.childNodes[i])
					{
						let group = groupsElement.removeChild(groupsElement.childNodes[i]);
					}
				}
			}
			function Player()
			{
				this.id = 42;
				this.name = "";
				this.team = 1;
				this.groups = {};
			}
			Player.prototype.isEnemy = function()
			{
				return this.team != player.team && !this.isNeutral();
			};
			Player.prototype.isIndependent = function()
			{
				return this.team == -1;//TODO
			};
			Player.prototype.isCivil = function()
			{
				return this.team == -1;
			};
			Player.prototype.isFriend = function()
			{
				return this.team == player.team;
			};
			function createGroupGlobal(unitNames, groupNames, pos)
			{
				unitsFromName(unitNames, function(units)
				{
					json = {
						type: "create",
						data: {
							pos: pos,
							id: -1,
							units: units
						}
					};
					console.log(json);
					//TODO groups
					messages.push(json);
					toBeSpawnedUnits = [];
					toBeSpawnedGroups = [];
				});
			}
			function showGroups()
			{
				reset();
				let name = gup("deck");
				let req = db.transaction(["decks"]).objectStore("decks").get(name);
				req.onsuccess = function(event)
				{
					if (req.result)
					{
						let deck = req.result;
						for (let group of deck.groups)
						{
							addGroup(group);
						}
					}
				};
			}
			function showInfantry()
			{
				reset();
				let name = gup("deck");
				let req = db.transaction(["decks"]).objectStore("decks").get(name);
				req.onsuccess = function(event)
				{
					if (req.result)
					{
						let deck = req.result;
						for (let unit of deck.units)
						{
							//TODO filter infantry
							addUnit(unit);
						}
					}
				};
			}
			function addUnit(unit)
			{
				let units = document.getElementById("buttonsBlock");
				let button = document.createElement("input");
				button.type = "button";
				button.value = unit;
				button.onclick = function()
				{
					let unit = this.value;
					toBeSpawnedUnits.push(unit);
				};
				units.appendChild(button);
			}
			function addGroup(group)
			{
				let groups = document.getElementById("buttonsBlock");
				let button = document.createElement("input");
				button.type = "button";
				button.value = group;
				button.onclick = function()
				{
					let group = this.value;
					toBeSpawnedGroups.push(group);
				};
				groups.appendChild(button);
			}
			function abortBuy()
			{
				reset();
			}
			function updateUI()
			{
				for (let objectID of Object.keys(allObjects))
				{
					let group = allObjects[objectID];
					if (group instanceof Group)
					{
						if (group.waypoints.length > 0)
						{
							let src = group.pos;
							let dst = group.waypoints[0];
							let minMoveDistance = group.representation.dbUnit.speed/(3.6*fps);
							let srcLatLon = new LatLon(src[0], src[1]);
							let dstLatLon = new LatLon(dst[0], dst[1]);
							let distance = srcLatLon.distanceTo(dstLatLon);
							if (distance < minMoveDistance)
							{
								group.waypoints.shift();
								group.dir = -1;
								group.setPos(dst);
								group.redraw();
							}
							else
							{
								let bearing = srcLatLon.finalBearingTo(dstLatLon);
								let destination = srcLatLon.destinationPoint(minMoveDistance, bearing);
								bearing = (360-bearing+90)%360;
								if (Math.round(group.dir) != Math.round(bearing))
								{
									group.dir = bearing;
									group.redraw();
								}
								group.setPos([destination.lat, destination.lon]);
							}
							group.moved = true;
						}
						else
						{
							group.moved = false;
						}
					}
				}
			/*
				//move groups
				for (let p of allPlayers)
				{
					for (let group of p.groups)
					{
						if (group.waypoints.length > 0)
						{
							let src = group.pos;
							let dst = group.waypoints[0];
							let minMoveDistance = group.representation.dbUnit.speed/(3.6*fps);
							let srcLatLon = new LatLon(src[0], src[1]);
							let dstLatLon = new LatLon(dst[0], dst[1]);
							let distance = srcLatLon.distanceTo(dstLatLon);
							if (distance < minMoveDistance)
							{
								group.waypoints.shift();
								group.dir = -1;
								group.setPos(dst);
								group.redraw();
							}
							else
							{
								let bearing = srcLatLon.finalBearingTo(dstLatLon);
								let destination = srcLatLon.destinationPoint(minMoveDistance, bearing);
								bearing = (360-bearing+90)%360;
								if (Math.round(group.dir) != Math.round(bearing))
								{
									group.dir = bearing;
									group.redraw();
								}
								group.setPos([destination.lat, destination.lon]);
							}
							group.moved = true;
						}
						else
						{
							group.moved = false;
						}
					}
				}
				
				//make spotted enemies visible
				let enemies = [];
				for (let p of allPlayers)
				{
					if (p.isEnemy())
					{
						for (let group of p.groups)
						{
							enemies.push(group);
						}
					}
				}
				for (let p of allPlayers)
				{
					if (p.isFriend())
					{
						for (let group of p.groups)
						{
							if (group.moved)
							{
								//recheck all enemies
								group.spots = [];
								for (let g of enemies)
								{
									group.handleDetection(g);
								}
							}
							else
							{
								//recheck all enemies that moved
								for (let g of enemies)
								{
									if (g.moved)
									{
										group.handleDetection(g);
									}
								}
							}
						}
					}
				}
				
				for (let p of allPlayers)
				{
					if (p.isFriend())
					{
						for (let group of p.groups)
						{
							for (let target of group.spots)//TODO list allTargets, select target
							{
								let srcLatLon = new LatLon(group.pos[0], group.pos[1]);
								let dstLatLon = new LatLon(target.pos[0], target.pos[1]);
								let distance = srcLatLon.distanceTo(dstLatLon);
								for (let unit of group.units)
								{
									for (let weapon of unit.weapons)
									{
										if (distance < weapon.dbWeapon.range)
										{
											weapon.use(group, target, 1000/fps);
										}
									}
								}
							}
						}
					}
				}
				
				//remove dead units
				for (let enemy of enemies)
				{
					for (let unit of enemy.units)
					{
						if (unit.healthLeft < 0)
						{
							let index = enemy.units.indexOf(unit);
							if (index > -1)
							{
								enemy.units.splice(index, 1);
								enemy.needsRedraw = true;
							}
						}
					}
					if (enemy.units.length == 0)
					{
						let index = enemies.indexOf(enemy);
						if (index > -1)
						{
							enemies.splice(index, 1);
						}
						let owner = enemy.owner;
						index = owner.groups.indexOf(enemy);
						if (index > -1)
						{
							owner.groups.splice(index, 1);
						}
						symbolSource.removeFeature(enemy.olObject);
						//TODO delete references in other groups (spots, spottedBy, ...)
					}
				}
				
				let now = Date.now();
				for (let p of allPlayers)
				{
					for (let group of p.groups)
					{
						if (group.lastShot > 0 && now - group.lastShot > 1000)
						{
							group.lastShot = 0;
							group.needsRedraw = true;
						}
						if (group.needsRedraw)
						{
							group.redraw();
						}
					}
				}*/
				if (messages.length > 0)
				{
					let json = {
						senderID: player.id,
						matchID: matchID,
						messages: messages
					};
					socket.emit("communicate", json);
				}
				messages = [];
			}
			let t = setInterval(updateUI, 1000/fps);
		</script>
	</body>
</html>
