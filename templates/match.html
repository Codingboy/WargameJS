<!doctype html>
<html lang="en">
	<head>
		<meta charset="utf-8">
		<meta http-equiv="X-UA-Compatible" content="IE=edge">
		<meta name="viewport" content="width=device-width, initial-scale=1">
		<link href="static/css/bootstrap.min.css" rel="stylesheet">
		<link rel="stylesheet" href="static/ol.css" type="text/css">
		<style>
			.map {
				height: 100%;
				width: 100%;
			}
		</style>
		<title>BFT</title>
	</head>
	<body onkeydown="handleKeyDown(event);" onkeyup="handleKeyUp(event);">
		<div class="container">
			<form class="form-horizontal">
				<div class="form-group" id="unitBlock">
					<span id="money"></span>
					<span id="conquestPoints"></span>
					<input type="button" onclick="showGroups()" value="Groups"/>
					<input type="button" onclick="showInfantry()" value="Infantry"/>
					<input type="button" onclick="showHeli()" value="Heli"/>
					<input type="button" onclick="abortBuy()" value="Abort"/>
				</div>
				<div class="form-group" id="buttonsBlock">
				</div>
				<div class="form-group" id="selectedBlock">
				</div>
				<script>
					function readyPlayer()
					{
						player.ready = !player.ready;
						let element = document.getElementById("ready");
						if (player.ready)
						{
							element.value = "Not Ready";
						}
						else
						{
							element.value = "Ready";
						}
						json = {
							player: player.id,
							ready: player.ready,
							matchID: matchID
						}
						console.log(json);
						socket.emit("ready", json);
					}
				</script>
				<input type="button" onclick="readyPlayer()" value="Ready" id="ready"/>
			<form>
		</div>
		<div id="map" class="map"></div>
		<script src="https://ajax.googleapis.com/ajax/libs/jquery/1.12.4/jquery.min.js"></script>
		<script src="static/js/bootstrap.min.js"></script>
		<script src="static/turf.min.js"></script>
		<script src="static/ol.js" type="text/javascript"></script>
		<script src="static/dms.js" type="text/javascript"></script>
		<script src="static/latlon-spherical.js" type="text/javascript"></script>
		<script src="static/milsymbol-master/dist/milsymbol.js"></script>
		<script src="static/core.js"></script>
		<script src="static/unit.js"></script>
		<script src="static/group.js"></script>
		<script src="static/weapon.js"></script>
			<script type="text/javascript" src="//cdnjs.cloudflare.com/ajax/libs/socket.io/1.3.5/socket.io.min.js"></script>
		<script>
			ms.addSymbolPart(
				function squareIcon() {
				var gbbox = new ms.BBox();
				if (this.square) {
					var anchor = { x: 100, y: 100 };
					if (this.properties.headquarters) {
					anchor = {
						x: this.properties.baseGeometry.bbox.x1,
						y: this.properties.baseGeometry.bbox.y2 + ms.getHqStafLength()
					};
					}
					var maxx = Math.max(anchor.x - this.bbox.x1, this.bbox.x2 - anchor.x);
					var maxy = Math.max(anchor.y - this.bbox.y1, this.bbox.y2 - anchor.y);
					var max = Math.max(maxx, maxy);
					gbbox.x1 = anchor.x - max;
					gbbox.y1 = anchor.y - max;
					gbbox.x2 = anchor.x + max;
					gbbox.y2 = anchor.y + max;
				}
				return { pre: [], post: [], bbox: gbbox };
				}
			);
			let allyC2 = [];
			let hostileC2 = [];
			let matchID = parseInt(gup("match"));
			let allPlayers = {};
			let allyGroups = {};
			let hostileGroups = {};
			let allObjects = {};
			let messages = [];
			let player = new Player();
			let mapJSON = {};
			let buildings = {};
			var socket = io.connect(location.protocol + '//' + document.domain + ':' + location.port);
			socket.open();
			let requestUpdate = false;
			socket.on("connect", function()
			{
				console.log("connect");
				let team = parseInt(gup("team"));
				socket.emit("join", {team: team, matchID: matchID});
			});
			socket.on("join", function(json)
			{
				console.log("join");
				console.log(json);
				player.id = json.id;
				player.name = json.name;
				player.team = json.team;
				requestUpdate = json.requestUpdate;
				delete json.requestUpdate;
				loadDeck(gup("deck"));
			});
			socket.on("joined", function(json)
			{
				console.log("joined");
				console.log(json);
				if (json.id != player.id)
				{
					let p = new Player();
					p.id = json.id;
					p.name = json.name;
					p.team = json.team;
					p.deck = json.deck;
					p.money = json.money;
					allPlayers[p.id] = p;
				}
				else
				{
					allPlayers[player.id] = player;
					if (requestUpdate)
					{
						socket.emit("requestUpdate", {receiverID: player.id, matchID: matchID});
					}
					else
					{
						loadMap(JSON.parse(gup("map")));
					}
				}
			});
			socket.on("requestUpdate", function(json)
			{
				console.log("requestUpdate");
				let receiverID = json.receiverID;
				if (receiverID != player.id)
				{
					console.log(json);
					let user = {};
					user.id = player.id;
					user.name = player.name;
					user.team = player.team;
					user.phase = player.phase;
					user.ready = player.ready;
					user.deck = player.deck;
					user.money = player.money;
					user.conquestPoints = player.conquestPoints;
					json.player = user;
					json.groups = [];
					//TODO myGroups
					json.map = mapJSON;
					socket.emit("update", json);
				}
			});
			socket.on("update", function(json)
			{
				console.log("update");
				let receiverID = json.receiverID;
				if (receiverID == player.id)
				{
					console.log(json);
					let user = {};
					let p = new Player();
					p.id = json.player.id;
					p.name = json.player.name;
					p.team = json.player.team;
					p.ready = json.player.ready;
					p.phase = json.player.phase;
					p.deck = json.player.deck;
					p.money = json.player.money;
					p.conquestPoints = json.player.conquestPoints;
					allPlayers[p.id] = p;
					if (p.phase != 0)
					{
						player.phase = p.phase;
						document.getElementById("ready").style.display = "none";
						lastMoneyTick = Date.now();
					}
					for (let group of json.groups)
					{
					
					}
					//TODO myGroups, c2
					if (json.map != {})
					{
						loadMap(json.map);
					}
				}
			});
			socket.on("ready", function(json)
			{
				console.log("update");
				let senderID = json.player;
				allPlayers[senderID].ready = json.ready;
				let notReady = 0;
				for (let playerID of Object.keys(allPlayers))
				{
					if (!allPlayers[playerID].ready)
					{
						notReady += 1;
						break;
					}
				}
				if (notReady == 0)
				{
					for (let playerID of Object.keys(allPlayers))
					{
						allPlayers[playerID].phase = 1;
						document.getElementById("ready").style.display = "none";
						lastMoneyTick = Date.now();
					}
				}
			});
			socket.on("communicate", function(json)
			{
				console.log("communicate");
				console.log(json);
				let senderID = json.senderID;
				let matchID = json.matchID;
				let messages = json.messages;
				for (message of messages)
				{
					let messageType = message.type;
					let messageData = message.data;
					if (messageType == "create")
					{
						let id = messageData.id;
						let pos = messageData.pos;
						let units = messageData.units;
						let owner = player;
						for (let playerID of Object.keys(allPlayers))
						{
							if (allPlayers[playerID].id == senderID)
							{
								owner = allPlayers[playerID];
								break;
							}
						}
						let group = new Group(owner, pos, id);
						for (let jsonUnit of units)
						{
							let unitID = jsonUnit.id;
							let deckID = jsonUnit.deckID;
							let dbUnit = owner.deck[deckID];
							let weapons = [];
							for (weapon of dbUnit.weapons)
							{
								let w = new Weapon(weapon, unitID+weapons.length+1);
								weapons.push(w);
							}
							let u = new Unit(dbUnit, weapons, group, unitID);
							for (weapon of u.weapons)
							{
								weapon.unit = u;
								allObjects[weapon.id] = weapon;
							}
							allObjects[u.id] = u;
							group.addUnit(u);
							if (u.dbUnit.c2 == 1)
							{
								if (group.owner.isFriend())
								{
									allyC2.push(u);
								}
								if (group.owner.isEnemy())
								{
									hostileC2.push(u);
								}
							}
						}
						allObjects[group.id] = group;
						if (owner.id != player.id)
						{
							if (owner.isFriend())
							{
								allyGroups[group.id] = group;
							}
							if (owner.isEnemy())
							{
								hostileGroups[group.id] = group;
							}
						}
						group.updateRepresentation();
						owner.money -= group.representation.price;
						if (owner == player)
						{
							showMoney();
						}
					}
					else if (messageType == "shoot")
					{
						if (senderID != player.id)
						{
							let id = messageData.id;
							let count = messageData.count;
							let shooterID = messageData.shooter;
							let weapon = allObjects[id];
							let shooter = allObjects[shooterID];
							weapon.bulletsLeft -= count;
							shooter.lastShot = Date.now();
							shooter.needsRedraw = true;
						}
					}
					else if (messageType == "reload")
					{
						if (senderID != player.id)
						{
							let id = messageData.id;
							let weapon = allObjects[id];
							weapon.bulletsLeft += weapon.dbWeapon.magazineSize;
							weapon.magazinesLeft -= 1;
						}
					}
					else if (messageType == "order")
					{
						let id = messageData.id;
						let order = messageData.order;
						let group = allObjects[id];
						if (messageData.add)
						{
							group.orders.push(order);
						}
						else
						{
							group.orders = [order];
						}
					}
					else if (messageType == "suppress")
					{
						let targetGroupID = messageData.targetGroupID;
						let weaponID = messageData.weaponID;//TODO statistic
						let suppression = messageData.suppression;
						let targetGroup = allObjects[targetGroupID];
						suppression += targetGroup.suppressed;
						if (suppression > 1)
						{
							suppression = 1;
						}
						targetGroup.suppressed = suppression;
					}
					else if (messageType == "dealDamage")
					{
						let unitID = messageData.unitID;
						let weaponID = messageData.weaponID;//TODO statistic
						let damage = messageData.damage;
						let unit = allObjects[unitID];
						unit.healthLeft -= damage;
						if (unit.healthLeft <= 0)
						{
							if (unit.dbUnit.c2 == 1)
							{
								if (unit.group.owner.isFriend())
								{
									let index = allyC2.indexOf(unit);
									if (index > -1)
									{
										allyC2.splice(index, 1);
									}
								}
								if (unit.group.owner.isEnemy())
								{
									let index = hostileC2.indexOf(unit);
									if (index > -1)
									{
										hostileC2.splice(index, 1);
									}
								}
							}
							let index = unit.group.units.indexOf(unit);
							if (index > -1)
							{
								unit.group.units.splice(index, 1);
								unit.group.updateRepresentation();
							}
							removeUnitReferences(unitID);
							if (unit.group.units.length == 0)
							{
								killGroup(unit.group.id);
							}
						}
					}
					else if (messageType == "remove")
					{
						let id = messageData.id;
						let group = allObjects[id];
						group.owner.money += group.representation.price;
						symbolSource.removeFeature(group.olObject);
						removeGroupReferences(id);
						delete allObjects[id];
						for (let unit of group.units)
						{
							delete allObjects[unit.id];
							for (let weapon of unit.weapons)
							{
								delete allObjects[weapon.id];
							}
							if (unit.dbUnit.c2 == 1)
							{
								if (group.owner.isFriend())
								{
									let index = allyC2.indexOf(unit);
									if (index > -1)
									{
										allyC2.splice(index, 1);
									}
								}
								if (group.owner.isEnemy())
								{
									let index = hostileC2.indexOf(unit);
									if (index > -1)
									{
										hostileC2.splice(index, 1);
									}
								}
							}
						}
						showMoney();
					}
				}
			});
			function removeGroupReferences(groupID)
			{
				for (let objectID of Object.keys(allObjects))
				{
					let group = allObjects[objectID];
					if (group instanceof Group)
					{
						for (let g of group.spots)//TODO other variables
						{
							if (g.id == groupID)
							{
								let index = group.spots.indexOf(g);
								if (index > -1)
								{
									group.spots.splice(index, 1);
								}
							}
						}
					}
				}
				let group = allObjects[groupID];
				delete group.owner.groups[groupID];
				if (group.owner.isFriend())
				{
					delete allyGroups[groupID];
				}
				if (group.owner.isEnemy())
				{
					delete hostileGroups[groupID];
				}
			}
			function removeUnitReferences(unitID)
			{
				//TODO
			}
			function killGroup(groupID)
			{
				let group = allObjects[groupID];
				removeGroupReferences(groupID);
				symbolSource.removeFeature(group.olObject);//TODO FIXME throws error
			}
			var visibleEnemyOpacity = 1.0;
			var invisibleEnemyOpacity = 0.1;
			var selectedOpacity = 1.0;
			var unselectedOpacity = 0.66;
			let lastMoneyTick = Date.now();
			
			let shift = false;
			let ctrl = false;
			
			let db;
			let toBeSpawnedUnits = [];
			let toBeSpawnedGroups = [];
			let selectedGroups = [];
			
			let fps = 10;
			let timeFactor = 10;
			
			let symbolSource = new ol.source.Vector({
				features: []
			});
			let symbolLayer = new ol.layer.Vector({
				source: symbolSource
			});
			let spawnSource = new ol.source.Vector();
			let spawnLayer = new ol.layer.Vector({
				source: spawnSource
			});
			let sectorSource = new ol.source.Vector();
			let sectorLayer = new ol.layer.Vector({
				source: sectorSource
			});
			let styles = {
				'landuse': {
					'forest': new ol.style.Style({
						stroke: new ol.style.Stroke({
							color: 'rgba(0, 255, 0, 1.0)',
							width: 1
						}),
						fill: new ol.style.Fill({
							color: 'rgba(0, 255, 0, 0.5)'
						})
					}),
					'farmland|meadow|orchard|plant_nursery|vineyard': new ol.style.Style({
						stroke: new ol.style.Stroke({
							color: 'rgba(0, 128, 0, 1.0)',
							width: 1
						}),
						fill: new ol.style.Fill({
							color: 'rgba(0, 128, 0, 0.5)'
						})
					}),
					'commercial|cemetery|construction|depot|allotments|farmyard|port|quarry|residential|retail|industrial|greenhouse_horticulture|garages': new ol.style.Style({
						stroke: new ol.style.Stroke({
							color: 'rgba(255, 0, 0, 1.0)',
							width: 1
						}),
						fill: new ol.style.Fill({
							color: 'rgba(255, 0, 0, 0.5)'
						})
					})
				},
				'natural': {
					'tree': new ol.style.Style({
						image: new ol.style.Circle({
							radius: 2,
							fill: new ol.style.Fill({
								color: 'rgba(140, 208, 95, 1.0)'
							}),
							stroke: null
						})
					}),
					'wood|tree_row': new ol.style.Style({
						stroke: new ol.style.Stroke({
							color: 'rgba(0, 255, 0, 1.0)',
							width: 1
						}),
						fill: new ol.style.Fill({
							color: 'rgba(0, 255, 0, 0.5)'
						})
					}),
					'water|bay': new ol.style.Style({
						stroke: new ol.style.Stroke({
							color: 'rgba(0, 0, 255, 1.0)',
							width: 1
						}),
						fill: new ol.style.Fill({
							color: 'rgba(0, 0, 255, 0.5)'
						})
					})
				},
				'waterway': {
					'stream|drain|ditch': new ol.style.Style({
						stroke: new ol.style.Stroke({
							color: 'rgba(0, 0, 128, 1.0)',
							width: 1
						}),
						fill: new ol.style.Fill({
							color: 'rgba(0, 0, 128, 0.5)'
						})
					}),
					'canal|river|fairway': new ol.style.Style({
						stroke: new ol.style.Stroke({
							color: 'rgba(0, 0, 255, 1.0)',
							width: 1
						}),
						fill: new ol.style.Fill({
							color: 'rgba(0, 0, 255, 0.5)'
						})
					})
				},
				'highway': {
					'track': new ol.style.Style({
						stroke: new ol.style.Stroke({
							color: 'rgba(255, 255, 255, 1.0)',
							width: 2
						})
					}),
					'motorway|trunk|primary|secondary|tertiary|unclassified|residential|service|motorway_link|trunk_link|primary_link|secondary_link|tertiary_link|living_street|pedestrian|bus_guideway|escape|raceway||||||': new ol.style.Style({
						stroke: new ol.style.Stroke({
							color: 'rgba(255, 255, 255, 1.0)',
							width: 3
						})
					})
				},
				'building': {
					'.*': new ol.style.Style({
						zIndex: 100,
						stroke: new ol.style.Stroke({
							color: 'rgba(255, 0, 0, 1.0)',
							width: 1
						}),
						fill: new ol.style.Fill({
							color: 'rgba(255, 0, 0, 0.5)'
						})
					})
				}
			};
			
			let buildingsSource = new ol.source.Vector();
			let buildingsLayer = new ol.layer.Vector({
				source: buildingsSource,
				style: function(feature) {
					for (let key in styles) {
						let value = feature.get(key);
						if (value !== undefined) {
							for (let regexp in styles[key]) {
								if (new RegExp(regexp).test(value)) {
									return styles[key][regexp];
								}
							}
						}
					}
					return null;
				}
			});

			let map = new ol.Map({
				target: "map",
				layers: [
					new ol.layer.Tile({
						preload: Infinity,
						source: new ol.source.OSM()
					}),
					buildingsLayer,
					spawnLayer,
					sectorLayer,
					symbolLayer
				],
				view: new ol.View({
					center: ol.proj.fromLonLat([8.2, 50.05]),
					//center: ol.proj.fromLonLat([8.19972, 50.04342]),
					zoom: 16
				}),
				interactions: ol.interaction.defaults({
					doubleClickZoom: false,
					shiftDragZoom: false,
					altShiftDragRotate: false,
					keyboard: false,
					pinchRotate: false,
					pinchZoom: false
				}),
				controls: ol.control.defaults().extend([
					new ol.control.ScaleLine()
				])
			});
			map.getViewport().addEventListener("contextmenu", function (evt)
			{
				evt.preventDefault();
				let latlon = ol.proj.transform(map.getEventCoordinate(evt), "EPSG:3857", "EPSG:4326");
				let lat = latlon[0];
				let lon = latlon[1];
				for (group of selectedGroups)
				{
					let json = {
						type: "order",
						data: {
							id: group.id,
							add: shift,
							order: {
								type: "move",
								waypoint: latlon
							}
						}
					};
					console.log(json);
					messages.push(json);
				}
			});
			map.on("singleclick", function(evt){
				let latlon = ol.proj.transform(evt.coordinate, "EPSG:3857", "EPSG:4326");
				let lat = latlon[0];
				let lon = latlon[1];
				if (toBeSpawnedUnits.length+toBeSpawnedGroups.length > 0)
				{
					if (player.phase == 0)
					{
						let feature = map.forEachFeatureAtPixel(evt.pixel, function (feature, layer)
						{
							if (layer == spawnLayer)
							{
								return feature;
							}
							return null;
						});
						if (feature)
						{
							let team = feature.get("team");
							if (player.team == team)
							{
								let moneySpend = 0;
								for (let unitID of toBeSpawnedUnits)
								{
									let dbUnit = player.deck[unitID];
									moneySpend += dbUnit.price;
								}
								if (player.money-moneySpend > mapJSON.minMoney)
								{
									createGroupGlobal(toBeSpawnedUnits, toBeSpawnedGroups, [lat, lon]);
								}
							}
						}
					}
					else
					{
						//TODO spawn in nearest SPAWNzone and move
						let moneySpend = 0;
						for (let unitID of toBeSpawnedUnits)
						{
							let dbUnit = player.deck[unitID];
							moneySpend += dbUnit.price;
						}
						if (player.money-moneySpend > mapJSON.minMoney)
						{
							createGroupGlobal(toBeSpawnedUnits, toBeSpawnedGroups, [lat, lon]);
						}
					}
				}
				else
				{
					let feature = map.forEachFeatureAtPixel(evt.pixel, function (feature, layer)
					{
						if (layer == symbolLayer)
						{
							return feature;
						}
						return null;
					});
					if (feature)
					{
						let group = feature.get("group");
						//TODO only if group of own team
						if (shift)
						{
							selectedGroups.push(group);
						}
						else
						{
							for (let g of selectedGroups)
							{
								g.opacity = unselectedOpacity;
								g.needsRedraw = true;
							}
							selectedGroups = [group];
						}
						group.opacity = selectedOpacity;
						group.needsRedraw = true;
					}
					else
					{
						for (let group of selectedGroups)
						{
							group.opacity = unselectedOpacity;
							group.needsRedraw = true;
						}
						selectedGroups = [];
					}
				}
			});
			function loadDeck(deckName)
			{
				let req = db.transaction(["decks"]).objectStore("decks").get(deckName);
				req.onsuccess = function(event)
				{
					let dbDeck = event.target.result;
					if (dbDeck)
					{
						unitsFromName(dbDeck.units, function(units)
						{
							let json = {};
							player.deck = units;
							json.id = player.id;
							json.name = player.name;
							json.team = player.team;
							json.deck = player.deck;
							json.matchID = matchID;
							socket.emit("joined", json);
						}, []);
					}
				}
			}
			function loadMap(json)
			{
				showMoney();
				mapJSON = json;
				let allyStyle = new ol.style.Style({
					fill: new ol.style.Fill({
						color: [0,0,255,0.2]
					}),
					stroke: new 	ol.style.Stroke({
						color: [0,0,255,0.4],
						width: 5
					})
				});
				let hostileStyle = new ol.style.Style({
					fill: new ol.style.Fill({
						color: [255,0,0,0.2]
					}),
					stroke: new 	ol.style.Stroke({
						color: [255,0,0,0.4],
						width: 5
					})
				});
				let sectorStyle = new ol.style.Style({
					fill: new ol.style.Fill({
						color: [0,0,0,0.2]
					}),
					stroke: new 	ol.style.Stroke({
						color: [0,0,0,0.4],
						width: 5
					})
				});
				let spawns = json.spawns;
				for (let spawn of spawns)
				{
					let team = spawn.team;
					let points = spawn.points;
					let polygon = new ol.geom.Polygon([points]);
					polygon.transform("EPSG:4326", "EPSG:3857");
					let feature = new ol.Feature(polygon);
					feature.set("team", team);
					if (player.team == team)
					{
						feature.setStyle(allyStyle);
					}
					else
					{
						feature.setStyle(hostileStyle);
					}
					spawnSource.addFeature(feature);
				}
				let sectors = json.sectors;
				for (let sector of sectors)
				{
					let points = sector.points;
					let polygon = new ol.geom.Polygon([points]);
					polygon.transform("EPSG:4326", "EPSG:3857");
					let feature = new ol.Feature(polygon);
					feature.setStyle(sectorStyle);
					sectorSource.addFeature(feature);
				}
				let teamMemberHere = false;
				for (let playerID of Object.keys(allPlayers))
				{
					let p = allPlayers[playerID];
					if (p.team == player.team)
					{
						teamMemberHere = true;
						player.conquestPoints = p.conquestPoints;
					}
				}
				if (teamMemberHere)
				{
					player.conquestPoints = json.conquestPoints;
				}
				map.getView().setCenter(ol.proj.transform([(json.bb[1]+json.bb[3])/2, (json.bb[0]+json.bb[2])/2], "EPSG:4326", "EPSG:3857"));
				map.getView().setZoom(16);
				let client = new XMLHttpRequest();
				client.open("POST", "https://overpass-api.de/api/interpreter");
				client.addEventListener("load", function() {
					let features = new ol.format.OSMXML().readFeatures(client.responseText,
					{
						featureProjection: map.getView().getProjection()
					});
					buildingsSource.addFeatures(features);
					for (let feature of features)
					{
						let coords = feature.getGeometry().getCoordinates();
						if (!Array.isArray(coords[0]))
						{
							continue;
						}
						if (coords[0].length < 4)
						{
							continue;
						}
						let convertedCoords = [];
						for (let coord of coords[0])
						{
							let convertedCoord = ol.proj.transform(coord, "EPSG:3857", "EPSG:4326");
							convertedCoords.push(convertedCoord);
						}
						/*let polygon = {
							"type": "Feature",
							"properties": {},
							"geometry": {
								"type": "Polygon",
								"coordinates": [
									convertedCoords
								]
							}
						}*/
						let polygon = turf.polygon([convertedCoords]);
						feature.set("polygon", polygon);
						let extent1 = feature.getGeometry().getExtent();
						let pos1 = ol.proj.transform([extent1[0], extent1[1]], "EPSG:3857", "EPSG:4326");
						let extent2 = feature.getGeometry().getExtent();
						let pos2 = ol.proj.transform([extent2[0], extent2[1]], "EPSG:3857", "EPSG:4326");
						let pos = [(pos1[0]+pos2[0])/2, (pos1[1]+pos2[1])/2];
						let factor = 100;
						pos = [Math.round(pos[0]*factor)/factor, Math.round(pos[1]*factor)/factor];
						let x = {};
						if (pos[0] in buildings)
						{
							x = buildings[pos[0]];
						}
						let y = [];
						if (pos[1] in x)
						{
							y = x[pos[1]];
						}
						y.push(feature);
						x[pos[1]] = y;
						buildings[pos[0]] = x;
					}
				});
				let query = ""+
"("+
"way[\"building\"]("+json.bb[0]+","+json.bb[1]+","+json.bb[2]+","+json.bb[3]+");"+
"rel[\"building\"]("+json.bb[0]+","+json.bb[1]+","+json.bb[2]+","+json.bb[3]+");"+
");"+
"(._;>;);"+
"out;"
				console.log(query);
				client.send(query);
			}
			function unitsFromName(unitNames, callback, units)
			{
				if (typeof units == "undefined")
				{
					units = [];
				}
				let unitName = unitNames.shift();
				unitFromName(unitName, function(dbUnit)
				{
					units.push(dbUnit);
					if (unitNames.length == 0)
					{
						callback(units);
					}
					else
					{
						unitsFromName(unitNames, callback, units);
					}
				});
			}
			function unitFromName(unitName, callback)
			{
				let req = db.transaction(["units"]).objectStore("units").get(unitName);
				req.onsuccess = function(event)
				{
					let dbUnit = event.target.result;
					if (dbUnit)
					{
						dbUnit.id = -1;
						for (let i=0; i<dbUnit.weapons.length; i++)
						{
							dbUnit.weaponCount = 0;
							weaponFromName(dbUnit.weapons[i], dbUnit, i, callback);
						}
						if (dbUnit.weapons.length == 0)
						{
							dbUnit.weapons = [];
							callback(dbUnit);
						}
					}
				};
			}
			function weaponFromName(weaponName, dbUnit, i, callback)
			{
				let req = db.transaction(["weapons"]).objectStore("weapons").get(weaponName);
				req.onsuccess = function(event)
				{
					let dbWeapon = event.target.result;
					if (dbWeapon)
					{
						dbWeapon.id = -1;
						dbUnit.weapons[i] = dbWeapon;
					}
					dbUnit.weaponCount += 1;
					if (dbUnit.weaponCount == dbUnit.weapons.length)
					{
						delete dbUnit.weaponCount;
						callback(dbUnit);
					}
				};
			}
			function handleKeyDown(e)
			{
				if (e.keyCode == 16)//shift
				{
					shift = true;
				}
				if (e.keyCode == 17)//ctrl
				{
					ctrl = true;
				}
				if (e.keyCode == 72)//h
				{
					for (let group of selectedGroups)
					{
						group.shootIfPossible = !group.shootIfPossible;
					}
				}
				if (e.keyCode == 76)//l
				{
					let json = {
						type: "order",
						data: {
							id: group.id,
							add: shift,
							order: {
								type: "altitude",
								altitude: 0
							}
						}
					};
					console.log(json);
					messages.push(json);
				}
				if (e.keyCode == 73)//i
				{
					//TODO show info
				}
				if (player.phase == 0)
				{
					if (e.keyCode == 46)
					{
						for (let group of selectedGroups)
						{
							removeGroup(group);
						}
					}
				}
			}
			function handleKeyUp(e)
			{
				if (e.keyCode == 16)
				{
					shift = false;
				}
				if (e.keyCode == 17)
				{
					ctrl = false;
				}
			}
			function removeGroup(group)
			{
				json = {
					type: "remove",
					data: {
						id: group.id
					}
				};
				console.log(json);
				messages.push(json);
			}
			function init()
			{
				window.indexedDB = window.indexedDB || window.mozIndexedDB || window.webkitIndexedDB || window.msIndexedDB;
				window.IDBTransaction = window.IDBTransaction || window.webkitIDBTransaction || window.msIDBTransaction;
				window.IDBKeyRange = window.IDBKeyRange || window.webkitIDBKeyRange || window.msIDBKeyRange;
				initDB(function(event)
				{
					db = event.target.result;
				});
			}
			init();
			function reset()
			{
				toBeSpawnedUnits = [];
				toBeSpawnedGroups = [];
				let groupsElement = document.getElementById("buttonsBlock");
				for (let i=0; i<groupsElement.childNodes.length; i++)
				{
					if (groupsElement.childNodes[i])
					{
						let group = groupsElement.removeChild(groupsElement.childNodes[i]);
						i--;
					}
				}
				showMoney();
			}
			function Player()
			{
				this.id = 42;
				this.name = "";
				this.team = 1;
				this.groups = {};
				this.ready = false;
				this.phase = 0;
				this.map = {};
				this.deck = [];
				this.money = 10000000;//TODO settings
				this.conquestPoints = 1000;
			}
			function showMoney()
			{
				let moneySpend = 0;
				for (let unitID of toBeSpawnedUnits)
				{
					let dbUnit = player.deck[unitID];
					moneySpend += dbUnit.price;
				}
				document.getElementById("money").innerHTML = Math.floor(player.money-moneySpend);
			}
			Player.prototype.isEnemy = function()
			{
				return this.team != player.team && !this.isIndependent() && !this.isCivil();
			};
			Player.prototype.isIndependent = function()
			{
				return this.team == -1;//TODO
			};
			Player.prototype.isCivil = function()
			{
				return this.team == -1;
			};
			Player.prototype.isFriend = function()
			{
				return this.team == player.team;
			};
			function createGroupGlobal(unitNames, groupNames, pos)
			{
				let units = [];
				for (let unitIndex of toBeSpawnedUnits)
				{
					let unit = player.deck[unitIndex];
					unit = JSON.parse(JSON.stringify(unit));
					let jsonUnit = {
						id: -1,
						ids: unit.weapons.length+1,
						deckID: unitIndex
					};
					units.push(jsonUnit);
				}
				json = {
					type: "create",
					data: {
						pos: pos,
						id: -1,
						units: units
					}
				};
				//TODO groups
				console.log(json);
				messages.push(json);
				toBeSpawnedUnits = [];
				toBeSpawnedGroups = [];
			}
			function showGroups()
			{//TODO
				reset();
				let name = gup("deck");
				let req = db.transaction(["decks"]).objectStore("decks").get(name);
				req.onsuccess = function(event)
				{
					if (req.result)
					{
						let deck = req.result;
						for (let group of deck.groups)
						{
							addGroup(group);
						}
					}
				};
			}
			function showInfantry()
			{
				reset();
				for (let i=0; i<player.deck.length; i++)
				{
					let dbUnit = player.deck[i];
					if (dbUnit.type == "Infantry")
					{
						addUnit(dbUnit, i);
					}
				}
			}
			function showHeli()
			{
				reset();
				for (let i=0; i<player.deck.length; i++)
				{
					let dbUnit = player.deck[i];
					if (dbUnit.type == "Heli")
					{
						addUnit(dbUnit, i);
					}
				}
			}
			function addUnit(unit, i)
			{
				let units = document.getElementById("buttonsBlock");
				let button = document.createElement("input");
				button.dataset.index = i;
				button.type = "button";
				button.value = unit.name;
				button.onclick = function()
				{
					let unit = this.value;
					toBeSpawnedUnits.push(parseInt(button.dataset.index));
					showMoney();
				};
				units.appendChild(button);
			}
			function addGroup(group)
			{//TODO
				let groups = document.getElementById("buttonsBlock");
				let button = document.createElement("input");
				button.type = "button";
				button.value = group;
				button.onclick = function()
				{
					let group = this.value;
					toBeSpawnedGroups.push(group);
				};
				groups.appendChild(button);
			}
			function abortBuy()
			{
				reset();
			}
			let flightHeight = 50;
			let lastUpdate = Date.now();
			function updateUI()
			{
let t0 = performance.now();
				let now = Date.now();
				let timeAvailable = now-lastUpdate;
				lastUpdate = now;
				let n = Math.floor((now-lastMoneyTick)/(1000*mapJSON.moneyTick));
				lastMoneyTick = lastMoneyTick + 1000*mapJSON.moneyTick*n;//TODO depend on timeAvailable
				
				//move groups
				if (player.phase > 0)
				{
					for (let objectID of Object.keys(allObjects))//TODO do for own groups, allyGroups and hostileGroups
					{
						let group = allObjects[objectID];
						if (group instanceof Group)
						{
							if (group.orders.length > 0)
							{
								let order = group.orders[0];
								if (order.type == "start")//TODO delete
								{
									if (group.altitude < flightHeight)
									{
										let climbRate = group.representation.speed/35;//TODO weight decreases climbrate
										let altitudeDiff = flightHeight-group.altitude;
										let timeNeeded = parseFloat(altitudeDiff)/climbRate;
										if (timeNeeded > timeAvailable)
										{
											group.altitude += climbRate*(parseFloat(timeAvailable)/1000);
											timeAvailable = 0;
										}
										else
										{
											timeAvailable -= timeNeeded;
											group.altitude = flightHeight;
											group.orders.shift();
											if (group.orders.length > 0)
											{
												order = group.orders[0];
											}
											else
											{
												continue;
											}
										}
									}
								}
								if (order.type == "altitude")//TODO merge with start
								{
									let consumedFuel = (parseFloat(group.representation.fuelConsumption)/(60))*(parseFloat(timeAvailable)/1000);
									if (group.fuel - consumedFuel >= 0)//TODO scale timeAvailable if false to fit it and empty the tank
									{
										if (group.representation.type == "Heli")//land heli
										{
											group.moved = true;
											if (group.altitude > 0)
											{
												let climbRate = group.representation.speed/35;//TODO weight decreases climbrate
												let altitudeDiff = group.altitude;
												let timeNeeded = parseFloat(altitudeDiff)/climbRate;
												if (timeNeeded > timeAvailable)
												{
													group.altitude -= climbRate*(parseFloat(timeAvailable)/1000);
													timeAvailable = 0;
												}
												else
												{
													timeAvailable -= timeNeeded;
													group.altitude = 0;
													group.orders.shift();
													if (group.orders.length > 0)
													{
														order = group.orders[0];
													}
													else
													{
														continue;
													}
												}
											}
										}
									}
								}
								if (order.type == "move" || order.type == "getin")
								{
									let consumedFuel = (parseFloat(group.representation.fuelConsumption)/(60))*(parseFloat(timeAvailable)/1000);
									if (group.fuel - consumedFuel >= 0)//TODO scale timeAvailable if false to fit it and empty the tank
									{
										group.fuel -= consumedFuel;
										if (group.representation.type == "Heli")//start heli
										{
											if (group.altitude < flightHeight)
											{
												let climbRate = group.representation.speed/35;//TODO weight decreases climbrate
												console.log("speed: "+group.representation.speed);
												console.log("climbRate: "+climbRate);
												let altitudeDiff = flightHeight-group.altitude;
												console.log("flightHeight: "+flightHeight);
												console.log("altitude: "+group.altitude);
												let timeNeeded = parseFloat(altitudeDiff)/climbRate;
												console.log("timeNeeded: "+timeNeeded);
												console.log("timeAvailable: "+timeAvailable);
												if (timeNeeded > timeAvailable)
												{
													group.altitude += climbRate*(parseFloat(timeAvailable)/1000);
													timeAvailable = 0;
												}
												else
												{
													timeAvailable -= timeNeeded;
													group.altitude = flightHeight;
												}
											}
										}
										let src = group.pos;
										let dst;//TODO getin
										if (order.type == "getin")
										{
											dst = order.target.pos;
										}
										else
										{
											dst = order.waypoint
										}
										let minMoveDistance = group.representation.speed/(36*(parseFloat(timeAvailable)/1000));
										let srcLatLon = new LatLon(src[0], src[1]);
										let dstLatLon = new LatLon(dst[0], dst[1]);
										let distance = srcLatLon.distanceTo(dstLatLon);
										if (distance < minMoveDistance)
										{
											group.orders.shift();
											if (group.orders.length > 0)
											{
												order = group.orders[0];
											}
											else
											{
												continue;
											}
											group.dir = -1;
											group.setPos(dst);
											group.needsRedraw = true;
											//TODO getin
										}
										else
										{
											let bearing = srcLatLon.finalBearingTo(dstLatLon);
											let destination = srcLatLon.destinationPoint(minMoveDistance, bearing);
											bearing = (360-bearing+90)%360;
											if (Math.round(group.dir) != Math.round(bearing))
											{
												group.dir = bearing;
												group.needsRedraw = true;
											}
											group.setPos([destination.lat, destination.lon]);
										}
										group.moved = true;
										let factor = 100;
										let pos = [Math.round(factor*group.pos[0])/factor, Math.round(factor*group.pos[1])/factor];
										if (pos[0] in buildings)
										{
											let buildingsX = buildings[pos[0]];
											if (pos[1] in buildingsX)
											{
												let buildingsY = buildingsX[pos[1]];
												let intersected = false;
												for (let feature of buildingsY)
												{
													if (turf.inside(group.pos, feature.get("polygon")))
													{
														group.building = feature.get("polygon");
														intersected = true;
													}
												}
												if (!intersected)
												{
													group.building = null;
												}
											}
											else
											{
												group.building = null;
											}
										}
										else
										{
											group.building = null;
										}
									}
									else
									{
										group.moved = false;
										group.building = null;
										if (group.representation.type == "Heli")//land heli
										{
											group.moved = true;
											if (group.altitude > 0)
											{
												let climbRate = group.representation.speed/35;//TODO weight decreases climbrate
												let altitudeDiff = group.altitude;
												let timeNeeded = parseFloat(altitudeDiff)/climbRate;
												if (timeNeeded > timeAvailable)
												{
													group.altitude -= climbRate*(parseFloat(timeAvailable)/1000);
													timeAvailable = 0;
												}
												else
												{
													timeAvailable -= timeNeeded;
													group.altitude = 0;
													group.orders.shift();
													if (group.orders.length > 0)
													{
														order = group.orders[0];
													}
													else
													{
														continue;
													}
												}
											}
										}
									}
								}
								else
								{
									group.moved = false;
									group.building = null;
								}
								if (order.type == "land")
								{
									if (group.altitude > 0)
									{
										let climbRate = group.representation.speed/35;//TODO weight decreases climbrate
										let altitudeDiff = group.altitude;
										let timeNeeded = parseFloat(altitudeDiff)/climbRate;
										if (timeNeeded > timeAvailable)
										{
											group.altitude -= climbRate*(parseFloat(timeAvailable)/1000);
											timeAvailable = 0;
										}
										else
										{
											timeAvailable -= timeNeeded;
											group.altitude = 0;
											group.orders.shift();
											if (group.orders.length > 0)
											{
												order = group.orders[0];
											}
											else
											{
												continue;
											}
										}
									}
								}
							}
							else//no orders
							{
								group.moved = false;
								group.building = null;
								let consumedFuel = (parseFloat(group.representation.fuelConsumption)/(60))*(parseFloat(timeAvailable)/1000);
								if (group.fuel - consumedFuel >= 0)//TODO && not landed
								{
									group.fuel -= consumedFuel;//TODO exclude vehicles
								}
								else
								{
									//TODO remove order
									//TODO land helis
								}
							}
							if (n > 0)//TODO move to top to prevent being ignored by continue
							{
								let feature = map.forEachFeatureAtPixel(map.getPixelFromCoordinate(ol.proj.transform(group.pos, "EPSG:4326", "EPSG:3857")), function (feature, layer)
								{
									if (layer == sectorLayer)
									{
										return feature;
									}
									return null;
								});
								if (feature)
								{
									for (let playerID of Object.keys(allPlayers))
									{
										let p = allPlayers[playerID];
										if (p.team == group.owner.team)
										{
											p.conquestPoints -= group.units.length;
										}
									}
								}
							}
						}
					}
					document.getElementById("conquestPoints").innerHTML = Math.round(player.conquestPoints);
				}
				
				//make spotted enemies visible
				for (let playerID of Object.keys(allPlayers))
				{
					let p = allPlayers[playerID];
					if (p.isFriend())
					{
						for (let groupID of Object.keys(p.groups))
						{
							let group = p.groups[groupID];
							if (group.moved)
							{
								//recheck all enemies
								group.spots = [];
								for (let gID of Object.keys(hostileGroups))
								{
									let g = hostileGroups[gID];
									group.handleDetection(g);
								}
							}
							else
							{
								//recheck all enemies that moved
								for (let gID of Object.keys(hostileGroups))
								{
									let g = hostileGroups[gID];
									if (g.moved)
									{
										group.handleDetection(g);
									}
								}
							}
						}
					}
				}
				
				//fight
				for (let objectID of Object.keys(player.groups))
				{
					let group = player.groups[objectID];
					if (group instanceof Group)
					{
						if (group.shootIfPossible)
						{
							for (let target of group.spots)//TODO list allTargets, select target
							{
								let srcLatLon = new LatLon(group.pos[0], group.pos[1]);
								let dstLatLon = new LatLon(target.pos[0], target.pos[1]);
								let distance = srcLatLon.distanceTo(dstLatLon);
								for (let unit of group.units)
								{
									for (let weapon of unit.weapons)
									{
										if (distance < weapon.dbWeapon.range)
										{
											weapon.use(group, target, 1000/fps);
										}
									}
								}
							}
						}
						if (group.lastShot > 0 && now - group.lastShot > 1000)
						{
							group.lastShot = 0;
							group.needsRedraw = true;
						}
						if (group.needsRedraw)
						{
							group.redraw();
						}
						group.suppressed = group.suppressed*(0.98+0.0199*(1-group.representation.courage));
					}
				}
				for (let objectID of Object.keys(allyGroups))
				{
					let group = allyGroups[objectID];
					if (group instanceof Group)
					{
						if (group.lastShot > 0 && now - group.lastShot > 1000)
						{
							group.lastShot = 0;
							group.needsRedraw = true;
						}
						if (group.needsRedraw)
						{
							group.redraw();
						}
						group.suppressed = group.suppressed*(0.98+0.0199*(1-group.representation.courage));
					}
				}
				for (let objectID of Object.keys(hostileGroups))
				{
					let group = hostileGroups[objectID];
					if (group instanceof Group)
					{
						if (group.lastShot > 0 && now - group.lastShot > 1000)
						{
							group.lastShot = 0;
							group.needsRedraw = true;
						}
						if (group.needsRedraw)
						{
							group.redraw();
						}
						group.suppressed = group.suppressed*(0.98+0.0199*(1-group.representation.courage));
					}
				}
				if (messages.length > 0)
				{
					let json = {
						senderID: player.id,
						matchID: matchID,
						messages: messages
					};
					socket.emit("communicate", json);
					messages = [];
				}
				if (player.phase > 0)
				{
					if (n > 0)//TODO move settings to server database and share on join
					{
						let money = mapJSON.moneyPerTick*n;
						for (let playerID of Object.keys(allPlayers))
						{
							let p = allPlayers[playerID];
							let inerestCost = 0;
							if (p.money < 0)
							{
								inerestCost = p.money*n*mapJSON.interest;
							}
							p.money += money+inerestCost;
						}
						showMoney();
					}
					if (hostileC2.length == 0)
					{
						endMatch(true);
					}
					if (allyC2.length == 0)
					{
						endMatch(false);
					}
					if (player.conquestPoints <= 0)
					{
						endMatch(true);
					}
					for (let playerID of Object.keys(allPlayers))
					{
						let p = allPlayers[playerID];
						if (p.isEnemy())
						{
							if (p.conquestPoints <= 0)
							{
								endMatch(false);
							}
							break;
						}
					}
				}
let t1 = performance.now();
if (t1-t0 > 50)
{
	console.log(t1-t0);
}
			}
			let intervalID = setInterval(updateUI, 1000/fps);
			function endMatch(win)
			{
				if (win)
				{
					console.log("You won!");
				}
				else
				{
					console.log("You lost!");
				}
				clearInterval(intervalID);
				//TODO show results
			}
		</script>
	</body>
</html>
