<!doctype html>
<html lang="en">
	<head>
		<meta charset="utf-8">
		<meta http-equiv="X-UA-Compatible" content="IE=edge">
		<meta name="viewport" content="width=device-width, initial-scale=1">
		<link href="static/css/bootstrap.min.css" rel="stylesheet">
		<link rel="stylesheet" href="static/ol.css" type="text/css">
		<style>
			.map {
				height: 100%;
				width: 100%;
			}
		</style>
		<title>BFT</title>
	</head>
	<body onkeydown="handleKeyDown(event);" onkeyup="handleKeyUp(event);">
		<div class="container">
			<form class="form-horizontal">
				<div class="form-group" id="unitBlock">
					<input type="button" onclick="showGroups()" value="Groups"/>
					<input type="button" onclick="showInfantry()" value="Infantry"/>
					<input type="button" onclick="abortBuy()" value="Abort"/>
				</div>
				<div class="form-group" id="buttonsBlock">
				</div>
				<div class="form-group" id="selectedBlock">
				</div>
				<script>
					function readyPlayer()
					{
						player.ready = !player.ready;
						let element = document.getElementById("ready");
						if (player.ready)
						{
							element.value = "Not Ready";
						}
						else
						{
							element.value = "Ready";
						}
						json = {
							player: player.id,
							ready: player.ready,
							matchID: matchID
						}
						console.log(json);
						socket.emit("ready", json);
					}
				</script>
				<input type="button" onclick="readyPlayer()" value="Ready" id="ready"/>
			<form>
		</div>
		<div id="map" class="map"></div>
		<script src="https://ajax.googleapis.com/ajax/libs/jquery/1.12.4/jquery.min.js"></script>
		<script src="static/js/bootstrap.min.js"></script>
		<script src="static/ol.js" type="text/javascript"></script>
		<script src="static/dms.js" type="text/javascript"></script>
		<script src="static/latlon-spherical.js" type="text/javascript"></script>
		<script src="static/milsymbol-master/dist/milsymbol.js"></script>
		<script src="static/core.js"></script>
		<script src="static/unit.js"></script>
		<script src="static/group.js"></script>
		<script src="static/weapon.js"></script>
    	<script type="text/javascript" src="//cdnjs.cloudflare.com/ajax/libs/socket.io/1.3.5/socket.io.min.js"></script>
		<script>
			let matchID = parseInt(gup("match"));
			let allPlayers = {};
			let allyGroups = {};
			let hostileGroups = {};
			let allObjects = {};
			let messages = [];
			let player = new Player();
			let mapJSON = {};
			var socket = io.connect(location.protocol + '//' + document.domain + ':' + location.port);
			socket.open();
			let requestUpdate = false;
			socket.on("connect", function()
			{
				console.log("connect");
				let team = parseInt(gup("team"));
				socket.emit("join", {team: team, matchID: matchID});
			});
			socket.on("join", function(json)
			{
				console.log("join");
				console.log(json);
				player.id = json.id;
				player.name = json.name;
				player.team = json.team;
				requestUpdate = json.requestUpdate;
				delete json.requestUpdate;
				loadDeck(gup("deck"));
			});
			socket.on("joined", function(json)
			{
				console.log("joined");
				console.log(json);
				if (json.id != player.id)
				{
					let p = new Player();
					p.id = json.id;
					p.name = json.name;
					p.team = json.team;
					p.deck = json.deck;
					allPlayers[p.id] = p;
				}
				else
				{
					allPlayers[player.id] = player;
					if (requestUpdate)
					{
						socket.emit("requestUpdate", {receiverID: player.id, matchID: matchID});
					}
					else
					{
						loadMap(JSON.parse(gup("map")));
					}
				}
			});
			socket.on("requestUpdate", function(json)
			{
				console.log("requestUpdate");
				let receiverID = json.receiverID;
				if (receiverID != player.id)
				{
					console.log(json);
					let user = {};
					user.id = player.id;
					user.name = player.name;
					user.team = player.team;
					user.phase = player.phase;
					user.ready = player.ready;
					json.player = user;
					json.groups = [];
					//TODO myGroups
					json.map = mapJSON;
					//TODO deck
					socket.emit("update", json);
				}
			});
			socket.on("update", function(json)
			{
				console.log("update");
				let receiverID = json.receiverID;
				if (receiverID == player.id)
				{
					console.log(json);
					let user = {};
					let p = new Player();
					p.id = json.player.id;
					p.name = json.player.name;
					p.team = json.player.team;
					p.ready = json.player.ready;
					p.phase = json.player.phase;
					allPlayers[p.id] = p;
					if (p.phase != 0)
					{
						player.phase = p.phase;
						document.getElementById("ready").style.display = "none";
					}
					for (let group of json.groups)
					{
					
					}
					//TODO myGroups
					//TODO deck
					if (json.map != {})
					{
						loadMap(json.map);
					}
				}
			});
			socket.on("ready", function(json)
			{
				console.log("update");
				let senderID = json.player;
				allPlayers[senderID].ready = json.ready;
				let notReady = 0;
				for (let playerID of Object.keys(allPlayers))
				{
					if (!allPlayers[playerID].ready)
					{
						notReady += 1;
						break;
					}
				}
				if (notReady == 0)
				{
					for (let playerID of Object.keys(allPlayers))
					{
						allPlayers[playerID].phase = 1;
						document.getElementById("ready").style.display = "none";
					}
				}
			});
			socket.on("communicate", function(json)
			{
				console.log("communicate");
				console.log(json);
				let senderID = json.senderID;
				let matchID = json.matchID;
				let messages = json.messages;
				for (message of messages)
				{
					let messageType = message.type;
					let messageData = message.data;
					if (messageType == "create")
					{
						let id = messageData.id;
						let pos = messageData.pos;
						let units = messageData.units;
						let owner = player;
						for (let playerID of Object.keys(allPlayers))
						{
							if (allPlayers[playerID].id == senderID)
							{
								owner = allPlayers[playerID];
								break;
							}
						}
						let group = new Group(owner, pos, id);
						for (unit of units)
						{
							let weapons = [];
							for (weapon of unit.weapons)
							{
								let w = new Weapon(weapon, weapon.id);
								weapons.push(w);
							}
							let u = new Unit(unit, weapons, group, unit.id);
							for (weapon of u.weapons)
							{
								weapon.unit = u;
								allObjects[weapon.id] = weapon;
							}
							allObjects[u.id] = u;
							group.addUnit(u);
						}
						allObjects[group.id] = group;
						if (owner.id != player.id)
						{
							if (owner.isFriend())
							{
								allyGroups[group.id] = group;
							}
							if (owner.isEnemy())
							{
								hostileGroups[group.id] = group;
							}
						}
						group.needsRedraw = true;
					}
					if (messageType == "addWaypoint")
					{
						let id = messageData.id;
						let waypoint = messageData.waypoint;
						let group = allObjects[id];
						group.waypoints.push(waypoint);
					}
					if (messageType == "setWaypoint")
					{
						let id = messageData.id;
						let waypoint = messageData.waypoint;
						let group = allObjects[id];
						group.waypoints = [waypoint];
					}
					if (messageType == "remove")
					{
						let id = messageData.id;
						let group = allObjects[id];
						symbolSource.removeFeature(group.olObject);
						//TODO remove from each other groups variables
						delete allObjects[id];
						for (let unit of group.units)
						{
							delete allObjects[unit.id];
							for (let weapon of unit.weapons)
							{
								delete allObjects[weapon.id];
							}
						}
						delete group.owner.groups[id];
						if (group.owner.isFriend())
						{
							delete allyGroups[id];
						}
						if (group.owner.isEnemy())
						{
							delete hostileGroups[id];
						}
					}
				}
			});
			var visibleEnemyOpacity = 1.0;
			var invisibleEnemyOpacity = 0.1;
			var selectedOpacity = 1.0;
			var unselectedOpacity = 0.66;
			
			let shift = false;
			let ctrl = false;
			
			let db;
			let toBeSpawnedUnits = [];
			let toBeSpawnedGroups = [];
			let selectedGroups = [];
			
			let fps = 10;
			let timeFactor = 10;
			
			let symbolSource = new ol.source.Vector({
				features: []
			});
			let symbolLayer = new ol.layer.Vector({
				source: symbolSource
			});
			let spawnSource = new ol.source.Vector();
			let spawnLayer = new ol.layer.Vector({
				source: spawnSource
			});
			let map = new ol.Map({
				target: "map",
				layers: [
					new ol.layer.Tile({
						preload: Infinity,
						source: new ol.source.OSM()
					}),
					spawnLayer,
					symbolLayer
				],
				view: new ol.View({
					center: ol.proj.fromLonLat([8.2, 50.05]),
					zoom: 15
				}),
				interactions: ol.interaction.defaults({
					doubleClickZoom: false,
					shiftDragZoom: false,
					altShiftDragRotate: false,
					keyboard: false,
					pinchRotate: false,
					pinchZoom: false
				}),
				controls: ol.control.defaults().extend([
					new ol.control.ScaleLine()
				])
			});
			map.on("singleclick", function(evt){
				let latlon = ol.proj.transform(evt.coordinate, "EPSG:3857", "EPSG:4326");
				let lat = latlon[0];
				let lon = latlon[1];
				if (toBeSpawnedUnits.length+toBeSpawnedGroups.length > 0)
				{
					if (player.phase == 0)
					{
						let feature = map.forEachFeatureAtPixel(evt.pixel, function (feature, layer)
						{
							if (layer == spawnLayer)
							{
								return feature;
							}
							return null;
						});
						if (feature)
						{
							team = feature.get("team");
							if (player.team == team)
							{
								createGroupGlobal(toBeSpawnedUnits, toBeSpawnedGroups, [lat, lon]);
							}
						}
					}
				}
				else
				{
					let feature = map.forEachFeatureAtPixel(evt.pixel, function (feature, layer)
					{
						if (layer == symbolLayer)
						{
							return feature;
						}
						return null;
					});
					let selected = false;
					if (feature)
					{
						group = feature.get("group");
						selected = true;
						if (shift)
						{
							selectedGroups.push(group);
						}
						else
						{
							for (let g of selectedGroups)
							{
								g.opacity = unselectedOpacity;
								g.needsRedraw = true;
							}
							selectedGroups = [group];
						}
						group.opacity = selectedOpacity;
						group.needsRedraw = true;
					}
					if (!selected && player.phase > 0)
					{
						for (group of selectedGroups)
						{
							if (shift)
							{
								json = {
									type: "addWaypoint",
									data: {
										id: group.id,
										waypoint: latlon
									}
								};
								console.log(json);
								messages.push(json);
							}
							else
							{
								json = {
									type: "setWaypoint",
									data: {
										id: group.id,
										waypoint: latlon
									}
								};
								console.log(json);
								messages.push(json);
							}
						}
					}
				}
			});
			function loadDeck(deckName)
			{
				let req = db.transaction(["decks"]).objectStore("decks").get(deckName);
				req.onsuccess = function(event)
				{
					let dbDeck = event.target.result;
					if (dbDeck)
					{
						unitsFromName(dbDeck.units, function(units)
						{
							let json = {};
							player.deck = units;
							json.id = player.id;
							json.name = player.name;
							json.team = player.team;
							json.deck = player.deck;
							socket.emit("joined", json);
						}, []);
					}
				}
			}
			function loadMap(json)
			{
				mapJSON = json;
				let allyStyle = new ol.style.Style({
					fill: new ol.style.Fill({
						color: [0,0,255,0.2]
					}),
					stroke: new 	ol.style.Stroke({
						color: [0,0,255,0.4],
						width: 5
					})
				});
				let hostileStyle = new ol.style.Style({
					fill: new ol.style.Fill({
						color: [255,0,0,0.2]
					}),
					stroke: new 	ol.style.Stroke({
						color: [255,0,0,0.4],
						width: 5
					})
				});
				let sectorStyle = new ol.style.Style({
					fill: new ol.style.Fill({
						color: [0,0,0,0.2]
					}),
					stroke: new 	ol.style.Stroke({
						color: [0,0,0,0.4],
						width: 5
					})
				});
				let spawns = json.spawns;
				for (let spawn of spawns)
				{
					let team = spawn.team;
					let points = spawn.points;
					let polygon = new ol.geom.Polygon([points]);
					polygon.transform("EPSG:4326", "EPSG:3857");
					let feature = new ol.Feature(polygon);
					feature.set("team", team);
					if (player.team == team)
					{
						feature.setStyle(allyStyle);
					}
					else
					{
						feature.setStyle(hostileStyle);
					}
					spawnSource.addFeature(feature);
				}
				let sectors = json.sectors;
				for (let sector of sectors)
				{
					let points = sector.points;
					let polygon = new ol.geom.Polygon([points]);
					polygon.transform("EPSG:4326", "EPSG:3857");
					let feature = new ol.Feature(polygon);
					feature.setStyle(sectorStyle);
					spawnSource.addFeature(feature);
				}
			}
			function unitsFromName(unitNames, callback, units)
			{
				if (typeof units == "undefined")
				{
					units = [];
				}
				let unitName = unitNames.shift();
				unitFromName(unitName, function(dbUnit)
				{
					units.push(dbUnit);
					if (unitNames.length == 0)
					{
						callback(units);
					}
					else
					{
						unitsFromName(unitNames, callback, units);
					}
				});
			}
			function unitFromName(unitName, callback)
			{
				let req = db.transaction(["units"]).objectStore("units").get(unitName);
				req.onsuccess = function(event)
				{
					let dbUnit = event.target.result;
					if (dbUnit)
					{
						dbUnit.id = -1;
						for (let i=0; i<dbUnit.weapons.length; i++)
						{
							dbUnit.weaponCount = 0;
							weaponFromName(dbUnit.weapons[i], dbUnit, i, callback);
						}
						if (dbUnit.weapons.length == 0)
						{
							dbUnit.weapons = [];
							callback(dbUnit);
						}
					}
				};
			}
			function weaponFromName(weaponName, dbUnit, i, callback)
			{
				let req = db.transaction(["weapons"]).objectStore("weapons").get(weaponName);
				req.onsuccess = function(event)
				{
					let dbWeapon = event.target.result;
					if (dbWeapon)
					{
						dbWeapon.id = -1;
						dbUnit.weapons[i] = dbWeapon;
					}
					dbUnit.weaponCount += 1;
					if (dbUnit.weaponCount == dbUnit.weapons.length)
					{
						delete dbUnit.weaponCount;
						callback(dbUnit);
					}
				};
			}
			function handleKeyDown(e)
			{
				if (e.keyCode == 16)
				{
					shift = true;
				}
				if (e.keyCode == 17)
				{
					ctrl = true;
				}
				if (player.phase == 0)
				{
					if (e.keyCode == 46)
					{
						for (let group of selectedGroups)
						{
							removeGroup(group);
						}
					}
				}
			}
			function handleKeyUp(e)
			{
				if (e.keyCode == 16)
				{
					shift = false;
				}
				if (e.keyCode == 17)
				{
					ctrl = false;
				}
			}
			function removeGroup(group)
			{
				json = {
					type: "remove",
					data: {
						id: group.id
					}
				};
				console.log(json);
				messages.push(json);
			}
			function init()
			{
				window.indexedDB = window.indexedDB || window.mozIndexedDB || window.webkitIndexedDB || window.msIndexedDB;
				window.IDBTransaction = window.IDBTransaction || window.webkitIDBTransaction || window.msIDBTransaction;
				window.IDBKeyRange = window.IDBKeyRange || window.webkitIDBKeyRange || window.msIDBKeyRange;
				initDB(function(event)
				{
					db = event.target.result;
				});
			}
			init();
			function reset()
			{
				toBeSpawnedUnits = [];
				toBeSpawnedGroups = [];
				let groupsElement = document.getElementById("buttonsBlock");
				for (let i=0; i<groupsElement.childNodes.length; i++)
				{
					if (groupsElement.childNodes[i])
					{
						let group = groupsElement.removeChild(groupsElement.childNodes[i]);
					}
				}
			}
			function Player()
			{
				this.id = 42;
				this.name = "";
				this.team = 1;
				this.groups = {};
				this.ready = false;
				this.phase = 0;
				this.map = {};
				this.deck = [];
			}
			Player.prototype.isEnemy = function()
			{
				return this.team != player.team && !this.isIndependent() && !this.isCivil();
			};
			Player.prototype.isIndependent = function()
			{
				return this.team == -1;//TODO
			};
			Player.prototype.isCivil = function()
			{
				return this.team == -1;
			};
			Player.prototype.isFriend = function()
			{
				return this.team == player.team;
			};
			function createGroupGlobal(unitNames, groupNames, pos)
			{
				unitsFromName(unitNames, function(units)
				{
					json = {
						type: "create",
						data: {
							pos: pos,
							id: -1,
							units: units//TODO send deck initially and here only the ids
						}
					};
					console.log(json);
					//TODO groups
					messages.push(json);
					toBeSpawnedUnits = [];
					toBeSpawnedGroups = [];
				});
			}
			function showGroups()
			{
				reset();
				let name = gup("deck");
				let req = db.transaction(["decks"]).objectStore("decks").get(name);
				req.onsuccess = function(event)
				{
					if (req.result)
					{
						let deck = req.result;
						for (let group of deck.groups)
						{
							addGroup(group);
						}
					}
				};
			}
			function showInfantry()
			{
				reset();
				let name = gup("deck");
				let req = db.transaction(["decks"]).objectStore("decks").get(name);
				req.onsuccess = function(event)
				{
					if (req.result)
					{
						let deck = req.result;
						for (let unit of deck.units)
						{
							//TODO filter infantry
							addUnit(unit);
						}
					}
				};
			}
			function addUnit(unit)
			{
				let units = document.getElementById("buttonsBlock");
				let button = document.createElement("input");
				button.type = "button";
				button.value = unit;
				button.onclick = function()
				{
					let unit = this.value;
					toBeSpawnedUnits.push(unit);
				};
				units.appendChild(button);
			}
			function addGroup(group)
			{
				let groups = document.getElementById("buttonsBlock");
				let button = document.createElement("input");
				button.type = "button";
				button.value = group;
				button.onclick = function()
				{
					let group = this.value;
					toBeSpawnedGroups.push(group);
				};
				groups.appendChild(button);
			}
			function abortBuy()
			{
				reset();
			}
			function updateUI()
			{
let t0 = performance.now();
				//move groups
				for (let objectID of Object.keys(allObjects))
				{
					let group = allObjects[objectID];
					if (group instanceof Group)
					{
						if (group.waypoints.length > 0)
						{
							let src = group.pos;
							let dst = group.waypoints[0];
							let minMoveDistance = group.representation.speed/(3.6*fps);
							let srcLatLon = new LatLon(src[0], src[1]);
							let dstLatLon = new LatLon(dst[0], dst[1]);
							let distance = srcLatLon.distanceTo(dstLatLon);
							if (distance < minMoveDistance)
							{
								group.waypoints.shift();
								group.dir = -1;
								group.setPos(dst);
								group.needsRedraw = true;
							}
							else
							{
								let bearing = srcLatLon.finalBearingTo(dstLatLon);
								let destination = srcLatLon.destinationPoint(minMoveDistance, bearing);
								bearing = (360-bearing+90)%360;
								if (Math.round(group.dir) != Math.round(bearing))
								{
									group.dir = bearing;
									group.needsRedraw = true;
								}
								group.setPos([destination.lat, destination.lon]);
							}
							group.moved = true;
						}
						else
						{
							group.moved = false;
						}
					}
				}
				
				//make spotted enemies visible
				for (let playerID of Object.keys(allPlayers))
				{
					let p = allPlayers[playerID];
					if (p.isFriend())
					{
						for (let groupID of Object.keys(p.groups))
						{
							let group = p.groups[groupID];
							if (group.moved)
							{
								//recheck all enemies
								group.spots = [];
								for (let gID of Object.keys(hostileGroups))
								{
									let g = hostileGroups[gID];
									group.handleDetection(g);
								}
							}
							else
							{
								//recheck all enemies that moved
								for (let gID of Object.keys(hostileGroups))
								{
									let g = hostileGroups[gID];
									if (g.moved)
									{
										group.handleDetection(g);
									}
								}
							}
						}
					}
				}
			/*
				
				//make spotted enemies visible
				for (let p of allPlayers)
				{
					if (p.isFriend())
					{
						for (let group of p.groups)
						{
							if (group.moved)
							{
								//recheck all enemies
								group.spots = [];
								for (let g of enemies)
								{
									group.handleDetection(g);
								}
							}
							else
							{
								//recheck all enemies that moved
								for (let g of enemies)
								{
									if (g.moved)
									{
										group.handleDetection(g);
									}
								}
							}
						}
					}
				}
				
				for (let p of allPlayers)
				{
					if (p.isFriend())
					{
						for (let group of p.groups)
						{
							for (let target of group.spots)//TODO list allTargets, select target
							{
								let srcLatLon = new LatLon(group.pos[0], group.pos[1]);
								let dstLatLon = new LatLon(target.pos[0], target.pos[1]);
								let distance = srcLatLon.distanceTo(dstLatLon);
								for (let unit of group.units)
								{
									for (let weapon of unit.weapons)
									{
										if (distance < weapon.dbWeapon.range)
										{
											weapon.use(group, target, 1000/fps);
										}
									}
								}
							}
						}
					}
				}
				
				//remove dead units
				for (let enemy of enemies)
				{
					for (let unit of enemy.units)
					{
						if (unit.healthLeft < 0)
						{
							let index = enemy.units.indexOf(unit);
							if (index > -1)
							{
								enemy.units.splice(index, 1);
								enemy.needsRedraw = true;
							}
						}
					}
					if (enemy.units.length == 0)
					{
						let index = enemies.indexOf(enemy);
						if (index > -1)
						{
							enemies.splice(index, 1);
						}
						let owner = enemy.owner;
						index = owner.groups.indexOf(enemy);
						if (index > -1)
						{
							owner.groups.splice(index, 1);
						}
						symbolSource.removeFeature(enemy.olObject);
						//TODO delete references in other groups (spots, spottedBy, ...)
					}
				}*/
				
				let now = Date.now();
				for (let objectID of Object.keys(allObjects))
				{
					let group = allObjects[objectID];
					if (group instanceof Group)
					{
						if (group.lastShot > 0 && now - group.lastShot > 1000)
						{
							group.lastShot = 0;
							group.needsRedraw = true;
						}
						if (group.needsRedraw)
						{
							group.redraw();
						}
					}
				}
				if (messages.length > 0)
				{
					let json = {
						senderID: player.id,
						matchID: matchID,
						messages: messages
					};
					socket.emit("communicate", json);
					messages = [];
				}
let t1 = performance.now();
if (t1-t0 > 10)
{
	console.log(t1-t0);
}
			}
			let t = setInterval(updateUI, 1000/fps);
		</script>
	</body>
</html>
