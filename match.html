<!doctype html>
<html lang="en">
	<head>
		<meta charset="utf-8">
		<meta http-equiv="X-UA-Compatible" content="IE=edge">
		<meta name="viewport" content="width=device-width, initial-scale=1">
		<link href="css/bootstrap.min.css" rel="stylesheet">
		<link rel="stylesheet" href="ol.css" type="text/css">
		<style>
			.map {
				height: 100%;
				width: 100%;
			}
		</style>
		<title>BFT</title>
	</head>
	<body onclick="onClick(event);">
		<div class="container">
			<form class="form-horizontal">
				<div class="form-group" id="unitBlock">
					<input type="button" onclick="showGroups()" value="Groups"/>
					<input type="button" onclick="showInfantry()" value="Infantry"/>
					<input type="button" onclick="abortBuy()" value="Abort"/>
				</div>
				<div class="form-group" id="buttonsBlock">
				</div>
				<div class="form-group" id="selectedBlock">
				</div>
			<form>
		</div>
		<div id="map" class="map"></div>
		<script src="https://ajax.googleapis.com/ajax/libs/jquery/1.12.4/jquery.min.js"></script>
		<script src="js/bootstrap.min.js"></script>
		<script src="ol.js" type="text/javascript"></script>
		<script src="dms.js" type="text/javascript"></script>
		<script src="latlon-spherical.js" type="text/javascript"></script>
		<script src="milsymbol-master/dist/milsymbol.js"></script>
		<script src="core.js"></script>
		<script>
			var visibleEnemyOpacity = 1.0;
			var invisibleEnemyOpacity = 0.1;
			var selectedOpacity = 1.0;
			var unselectedOpacity = 0.66;
			let blufor = new Player();
			blufor.name = "Coding";
			blufor.team = 1;
			let opfor = new Player();
			opfor.team = 2;
			opfor.name = "duli";
			let player = blufor;
			let allPlayers = [];
			allPlayers.push(blufor);
			allPlayers.push(opfor);
			
			let shift = false;
			let ctrl = false;
			
			let db;
			let toBeSpawnedUnits = [];
			let toBeSpawnedGroups = [];
			let selectedGroups = [];
			
			let fps = 10;
			let timeFactor = 10;
			
			let symbolSource = new ol.source.Vector({
				features: []
			});
			let symbolLayer = new ol.layer.Vector({
				source: symbolSource
			});
			let map = new ol.Map({
				target: "map",
				layers: [
					new ol.layer.Tile({
						preload: Infinity,
						source: new ol.source.OSM()
					}),
					symbolLayer
				],
				view: new ol.View({
					center: ol.proj.fromLonLat([8.2, 50.05]),
					zoom: 15
				}),
				interactions: ol.interaction.defaults({
					doubleClickZoom: false,
					shiftDragZoom: false,
					altShiftDragRotate: false,
					keyboard: false,
					pinchRotate: false,
					pinchZoom: false
				}),
				controls: ol.control.defaults().extend([
					new ol.control.ScaleLine()
				])
			});
			map.on("singleclick", function(evt){
				let latlon = ol.proj.transform(evt.coordinate, "EPSG:3857", "EPSG:4326");
				let lat = latlon[0];
				let lon = latlon[1];
				if (toBeSpawnedUnits.length+toBeSpawnedGroups.length > 0)
				{
					let group = new Group(player, [lat, lon]);
					for (unit of toBeSpawnedUnits)
					{
						group.addUnit(unit);
					}
					for (g of toBeSpawnedGroups)
					{
						group.addGroup(g);
					}
					toBeSpawnedUnits = [];
					toBeSpawnedGroups = [];
				}
				else
				{
					let selected = false;
					feature = map.forEachFeatureAtPixel(evt.pixel, function (feature, layer)
					{
						return feature;
					});
					if (feature)
					{
						group = feature.get("group");
						selected = true;
						if (shift)
						{
							selectedGroups.push(group);
						}
						else
						{
							for (let g of selectedGroups)
							{
								g.opacity = unselectedOpacity;
								g.needsRedraw = true;
							}
							selectedGroups = [group];
						}
						group.opacity = selectedOpacity;
						group.needsRedraw = true;
					}
					if (!selected)
					{
						for (group of selectedGroups)
						{
							if (shift)
							{
								group.waypoints.push(latlon);
							}
							else
							{
								group.waypoints = [latlon];
							}
						}
					}
				}
			});
			function onClick(e){
				shift = e.shiftKey;
				ctrl = e.ctrlKey;
			}
			function init()
			{
				window.indexedDB = window.indexedDB || window.mozIndexedDB || window.webkitIndexedDB || window.msIndexedDB;
				window.IDBTransaction = window.IDBTransaction || window.webkitIDBTransaction || window.msIDBTransaction;
				window.IDBKeyRange = window.IDBKeyRange || window.webkitIDBKeyRange || window.msIDBKeyRange;
				initDB(function(event)
				{
					db = event.target.result;
					let group = new Group(opfor, [8.2, 50.05]);
					for (let i=0; i<32; i++)
					{
						group.addUnit("Rifleman");
					}
				});
			}
			init();
			function reset()
			{
				toBeSpawnedUnits = [];
				toBeSpawnedGroups = [];
				let groupsElement = document.getElementById("buttonsBlock");
				for (let i=0; i<groupsElement.childNodes.length; i++)
				{
					if (groupsElement.childNodes[i])
					{
						let group = groupsElement.removeChild(groupsElement.childNodes[i]);
					}
				}
			}
			function showGroups()
			{
				reset();
				let name = gup("deck");
				let req = db.transaction(["decks"]).objectStore("decks").get(name);
				req.onsuccess = function(event)
				{
					if (req.result)
					{
						let deck = req.result;
						for (let group of deck.groups)
						{
							addGroup(group);
						}
					}
				};
			}
			function showInfantry()
			{
				reset();
				let name = gup("deck");
				let req = db.transaction(["decks"]).objectStore("decks").get(name);
				req.onsuccess = function(event)
				{
					if (req.result)
					{
						let deck = req.result;
						for (let unit of deck.units)
						{
							//TODO filter infantry
							addUnit(unit);
						}
					}
				};
			}
			function addUnit(unit)
			{
				let units = document.getElementById("buttonsBlock");
				let button = document.createElement("input");
				button.type = "button";
				button.value = unit;
				button.onclick = function()
				{
					let unit = this.value;
					toBeSpawnedUnits.push(unit);
				};
				units.appendChild(button);
			}
			function addGroup(group)
			{
				let groups = document.getElementById("buttonsBlock");
				let button = document.createElement("input");
				button.type = "button";
				button.value = group;
				button.onclick = function()
				{
					let group = this.value;
					toBeSpawnedGroups.push(group);
				};
				groups.appendChild(button);
			}
			function abortBuy()
			{
				reset();
			}
			function updateUI()
			{
				//move groups
				for (let p of allPlayers)
				{
					for (let group of p.groups)
					{
						if (group.waypoints.length > 0)
						{
							let src = group.pos;
							let dst = group.waypoints[0];
							let minMoveDistance = group.representation.dbUnit.speed/(3.6*fps);
							let srcLatLon = new LatLon(src[0], src[1]);
							let dstLatLon = new LatLon(dst[0], dst[1]);
							let distance = srcLatLon.distanceTo(dstLatLon);
							if (distance < minMoveDistance)
							{
								group.waypoints.shift();
								group.dir = -1;
								group.setPos(dst);
								group.redraw();
							}
							else
							{
								let bearing = srcLatLon.finalBearingTo(dstLatLon);
								let destination = srcLatLon.destinationPoint(minMoveDistance, bearing);
								bearing = (360-bearing+90)%360;
								if (Math.round(group.dir) != Math.round(bearing))
								{
									group.dir = bearing;
									group.redraw();
								}
								group.setPos([destination.lat, destination.lon]);
							}
							group.moved = true;
						}
						else
						{
							group.moved = false;
						}
					}
				}
				
				//make spotted enemies visible
				let enemies = new Set();
				for (let p of allPlayers)
				{
					if (p.isEnemy())
					{
						for (let group of p.groups)
						{
							enemies.add(group);
						}
					}
				}
				for (let p of allPlayers)
				{
					if (p.isFriend())
					{
						for (let group of p.groups)
						{
							if (group.moved)
							{
								//recheck all enemies
								group.spots = [];
								for (let g of enemies)
								{
									group.handleDetection(g);
								}
							}
							else
							{
								//recheck all enemies that moved
								for (let g of enemies)
								{
									if (g.moved)
									{
										group.handleDetection(g);
									}
								}
							}
						}
					}
				}
				
				for (let p of allPlayers)
				{
					if (p.isFriend())
					{
						for (let group of p.groups)
						{
							for (let target of group.spots)//TODO list allTargets, select target
							{
								let srcLatLon = new LatLon(group.pos[0], group.pos[1]);
								let dstLatLon = new LatLon(target.pos[0], target.pos[1]);
								let distance = srcLatLon.distanceTo(dstLatLon);
								for (let unit of group.units)
								{
									for (let weapon of unit.weapons)
									{
										if (distance < weapon.dbWeapon.range)
										{
											weapon.use(group, target, 1000/fps);
										}
									}
								}
							}
						}
					}
				}
				
				//remove dead units
				for (let enemy of enemies)
				{
					for (let unit of enemy.units)
					{
						if (unit.healthLeft < 0)
						{
							let index = enemy.units.indexOf(unit);
							if (index > -1)
							{
								enemy.units.splice(index, 1);
								enemy.needsRedraw = true;
							}
						}
					}
					if (enemy.units.length == 0)
					{
						let index = enemies.indexOf(enemy);
						if (index > -1)
						{
							enemies.splice(index, 1);
						}
						let owner = enemy.owner;
						index = owner.groups.indexOf(enemy);
						if (index > -1)
						{
							owner.groups.splice(index, 1);
						}
						symbolSource.removeFeature(enemy.olObject);
						//TODO delete references in other groups (spots, spottedBy, ...)
					}
				}
				
				for (let p of allPlayers)
				{
					for (let group of p.groups)
					{
						if (group.needsRedraw)
						{
							group.redraw();
						}
					}
				}
			}
			let t = setInterval(updateUI, 1000/fps);
		</script>
	</body>
</html>
